% Use the CSV generated by DataExtraction
% This is easier than calling C# directly

[annotations_ob, datastore_ob] = load_data("in/oblivion/extracted_data_oblivion.csv", "in/oblivion/voice/");
samplerate_ob = 44100;
write_counts_table(annotations_ob.EmotionType, "out/category_counts_oblivion.csv");

[annotations_nv, datastore_nv] = load_data("in/newvegas/extracted_data_new_vegas.csv", "in/newvegas/voice/");
samplerate_nv = 22050;
write_counts_table(annotations_nv.EmotionType, "out/category_counts_new_vegas.csv");

function [annotations, datastore] = load_data(csvPath, voicePath)
    annotations = readtable(csvPath, "Delimiter", ",");
    annotations.EmotionType = categorical(annotations.EmotionType);

    datastore = audioDatastore(voicePath, "IncludeSubfolders", true);

    % Create a dictionary mapping. Need to use the full paths here and convert to strings
    fullPaths = string(fullfile(datastore.Folders{1}, annotations.ExtractedPath));
    dict = dictionary(fullPaths, annotations.EmotionType);

    % Create a labels array for the datastore
    labels = arrayfun(@(x) dict(x), datastore.Files);

    datastore.Labels = labels;
end

% Write category counts to file for LaTeX
function write_counts_table(annotations, file)
    disp('Category counts:');
    names = categories(annotations);
    counts = countcats(annotations);
    for i = 1:length(names)
        fprintf('%s: %d\n', names{i}, counts(i));
    end

    countsTable = table(names, counts, 'VariableNames', ["Name", "Count"]);
    writetable(countsTable, file);
end
